#!/usr/bin/env python

## This code was modified from the aligner available at 
## https://github.com/callison-burch/dreamt.git

import optparse
import sys
import os
import time
from collections import defaultdict
import pickle

optparser = optparse.OptionParser()
optparser.add_option("-d", "--data", dest="train", default="data/hansards", help="Data filename prefix (default=data)")
optparser.add_option("-e", "--english", dest="english", default="e", help="Suffix of English filename (default=e)")
optparser.add_option("-f", "--french", dest="french", default="f", help="Suffix of French filename (default=f)")
optparser.add_option("-k", "--iterations", dest="iterations", default=1, type="int", help="Number of iterations for which to run algorithm (default=1)")
optparser.add_option("-i", "--initial", dest="initial", default=0.1, type="float", help="Initial value for t(f|e) [Brown et al. eq. 17] (default=0.1)")
optparser.add_option("-n", "--num_sentences", dest="num_sents", default=sys.maxint, type="int", help="Number of sentences to use for training and alignment")
optparser.add_option("-x", "--threshold", dest="threshold", default=0.15, type="float", help="Threshold value for alignment (default=0.15)")
(opts, _) = optparser.parse_args()

f_data = "%s.%s" % (opts.train, opts.french)
e_data = "%s.%s" % (opts.train, opts.english)

t = defaultdict(lambda: [opts.initial, opts.initial, 0.0])
pairs = [[sentence.strip().split() for sentence in pair] for pair in zip(open(f_data), open(e_data))[:opts.num_sents]]

sys.stderr.write("Building French-English\n")
lam = defaultdict(lambda: [0.0, 0.0])
for i in range(opts.iterations):
  sys.stderr.write("Now doing iteration %i\n" % (i + 1))
  for pair in pairs:
    for w1 in pair[0]:
      denom = sum([t[(w1, w2)][0] for w2 in set(pair[1])])
      for w2 in pair[1]:
        t[(w1, w2)][2] += t[(w1, w2)][0] / denom
        lam[w2][1] += t[(w1, w2)][0] / denom
  for w2 in lam: 
    lam[w2][0] = lam[w2][1]
    lam[w2][1] = 0.0
  for t_i in t: 
    t[t_i][0] = t[t_i][2] / lam[t_i[1]][0]
    t[t_i][2] = 0.0

sys.stderr.write("Building English-French\n")
lam = defaultdict(lambda: [0.0, 0.0])
for i in range(opts.iterations):
  sys.stderr.write("Now doing iteration %i\n" % (i + 1))
  for pair in pairs:
    for w1 in pair[1]:
      denom = sum([t[(w2, w1)][1] for w2 in set(pair[0])])
      for w2 in pair[0]:
        t[(w2, w1)][2] += t[(w2, w1)][1] / denom
        lam[w2][1] += t[(w2, w1)][1] / denom
  for w2 in lam: 
    lam[w2][0] = lam[w2][1]
    lam[w2][1] = 0.0
  for t_i in t: 
    t[t_i][1] = t[t_i][2] / lam[t_i[0]][0]
    t[t_i][2] = 0.0

for t_i in t:
  t[t_i][2] = (t[t_i][0] + t[t_i][1])/2

sys.stderr.write("Now writing out alignment")
for pair in pairs:
  for (i, w1) in enumerate(pair[0]):
    max_val = -1
    max_index = 0
    for (j, w2) in enumerate(pair[1]):
      if t[(w1, w2)][2] > max_val:
        max_val = t[(w1, w2)][2]
        max_index = j
    if max_val > opts.threshold: sys.stdout.write("%i-%i " % (i, max_index))
  sys.stdout.write("\n")






